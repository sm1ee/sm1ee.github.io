---
layout: post
disqus: true
cover: 'assets/images/cover6.jpg'
navigation: True
title: sctf2018(samsung) write-ups
date: 2018-07-19 10:18:00
tags: CTFs sctf2018
subclass: 'post tag-fiction'
logo: 'assets/images/smlee.png'
author: smlee
categories: smlee
---




# dingJMax

```c
#define _GNU_SOURCE
#include <ncurses.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <stdio.h>

typedef int (*origin_wgetch)(WINDOW*);

int count = 0;

int wgetch(WINDOW *win){
	char *line = 0x0000000000607648;
	char key[] = {'d','f','j','k'};

	for(int i = 0; i < 4; i++){
		if(line[i] == 'o' && ++count >= 20){
				count = 0;
				return key[i];
		}
	}

	origin_wgetch _wgetch = (origin_wgetch)dlsym(RTLD_NEXT, "wgetch");
	return _wgetch(win);
}

```

# BankRobber

```javascript
pragma solidity ^0.4.18;

contract SCTFBank{
    event LogBalance(address addr, uint256 value);
    mapping (address => uint256) private balance;
    mapping (address => bool) private claimedBonus;
    uint256 private donation_deposit;
    address private owner;

    constructor() public{
        owner = msg.sender;
    }
    
    function showBalance(address addr) public {
        emit LogBalance(addr, balance[addr]);
    }

    function withdraw(uint256 value) public{
        require(balance[msg.sender] >= value);
        balance[msg.sender] -= value;
        msg.sender.transfer(value);

    }
    
    function transfer(address to, uint256 value) public {
        require(balance[msg.sender] >= value && balance[to]+value >= balance[to]);
        balance[msg.sender] -= value;
        balance[to]+=value;
    }

    function multiTransfer(address[] to_list, uint256 value) public {
	uint256 tmp = value*to_list.length;
	require(tmp / value == to_list.length);
        require(balance[msg.sender] >= (value*to_list.length));
        balance[msg.sender] -= (value*to_list.length);
        for(uint i=0; i < to_list.length; i++){
            require(balance[to_list[i]]+value >= balance[to_list[i]]);
            balance[to_list[i]] += value;
        }
    }
    
    function donate(uint256 value) public {
        require(balance[msg.sender] >= value);
        balance[msg.sender] -= value;
        require(donation_deposit+value >= donation_deposit);
        donation_deposit += value;

    }

    function deliver(address to) public {
    require(!claimedBonus[to]);
        require(msg.sender == owner);
        claimedBonus[to] = true;
        to.transfer(donation_deposit);
        donation_deposit = 0;
    }
    
    function () payable public {
        require(balance[msg.sender]+msg.value >= balance[msg.sender]);
        balance[msg.sender]+=msg.value;
    }
}
//END
```

# HideInSSL

[sslpacket.pcap](https://github.com/sm1ee/ctf/blob/master/sctf2018/HideInSSL/sslpacket.pcap)
```python
#!/usr/bin/env python
from pwn import *
from scapy.all import *

def requset(_packet):
    return _packet[TCP].payload.getlayer(Raw).load[0x13:0x2B]

def response(_packet):
    return int(_packet[TCP].payload.getlayer(Raw).load[0]);

jpg_gadget = ""
packets = rdpcap('./sslpacket.pcap') 

log.info("Start")
for i, packet in enumerate(packets):
    packet_len = len(packet)

    if packet_len == 74 and packet[TCP].flags == 0x02:
        f = open("flag_%s.jpg" % i, "wb")
    elif packet_len >= 246 and packet_len <= 250:
        jpg_gadget = requset(packet)
    elif packet_len == 67:
        if response(packet) == True:
            f.write(jpg_gadget)
    elif packet_len == 270:
        log.info("Wrote it in file.")
        EOF = True
        f.close()
log.info("Done !")
f.close()
```


